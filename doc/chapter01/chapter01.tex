\chapter{入门知识}
\section{输入输出}
\noindent{\bfseries{cin}}:处理标准输入。\\
{\bfseries{cout}}:处理标准输出。\\
{\bfseries{cerr}}:输出警告和错误消息。\\
{\bfseries{clog}}:输出程序运行时的一般信息。

\section{标准命名空间}
标准库使用的所有名字都在命名空间{\bfseries{std}}中。%
命名空间可以帮助我们避免不经意的名字定义冲突，%
以及使用库中相同名字导致的冲突。%

\section{流作为条件}
当我们使用一个{\bfseries{istream}}对象作为条件时，其效果是检测流的状态。%
如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符{\bfseries{EOF}},%
或遇到一个无效输入时，%
{\bfseries{istream}}对象的状态会变为无效。%
处于无效状态的{\bfseries{istream}}对象会使条件为假。

\section{基本内置类型}
C++定义了一套包括{\bfseries{算术类型}}和{\bfseries{空类型}}在内的基本数据类型。%
其中算术类型包含了字符、整型数、布尔值和浮点型。%
空类型不对应具体的值，%
仅用于一些特殊的场合。%

\section{带符号类型和无符号类型}
除去布尔值类型和扩展的字符类型之外，其他的整型可以分为{\bfseries{带符号的}}和{\bfseries{无符号的}}两种。%
带符号的类型可以表示{\bfseries{正数}}、{\bfseries{负数}}和{\bfseries{0}}。%

\section{类型转换}
\begin{itemize}
\item{当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0，则结果为false，否则结果为true。}
\item{当我们把一个布尔类型的值赋给非布尔类型时，初始值为false，则结果为0，否则结果为1。}
\item{当我们把一个浮点值赋给整数时，采取的是截断处理，将仅保留小数点之前的值。}
\item{当我们把一个整数赋给浮点数时，小数部分为0。此时要注意两者的所占空间的大小。}
\item{当我们赋给带符号类型一个超出它表示范围的值时，结果是{\bfseries{为定义的}}。}
\end{itemize}

\section{进制}
以0开头的整数代表八进制，以0x和0X开头的代表十六进制数。

\section{转义序列}
\begin{table}[hbpt]
  \centering
  \begin{tabular}{cc}\hline\hline
    换行符 & $\backslash{n}$ \\\hline
    纵向制表符 & $\backslash{v}$ \\\hline
    反斜线 & $\backslash{\backslash}$ \\\hline
    回车符 & $\backslash{r}$ \\\hline
    横向制表符 & $\backslash{t}$ \\\hline
    退格符 & $\backslash{b}$ \\\hline
    问号 & $\backslash{?}$ \\\hline
    进纸符 & $\backslash{f}$ \\\hline
    报警符 & $\backslash{a}$ \\\hline
    双引号 & $\backslash{"}$ \\\hline
    单引号 & $\backslash{'}$ \\\hline\hline
  \end{tabular}
  \caption{C++转义序列}
\end{table}

\section{变量}
变量提供了一个具名的、可供程序操作的存储空间。
\subsection{变量定义}
变量定义的基本形式是：首先是类型说明符，
随后紧跟由一个或多个变量名组成的列表，%
其中变量名以逗号分隔，%
最后以分号结束。%
列表中每个变量名的类型都由类型说明符指定，%
定义时还可以为一个或多个变量赋初值。%
\subsection{初始值}
当对象在创建时获得了一个特定的值，我们说这个对象被{\bfseries{初始化}}了。\\%
{\color{red}{初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，%
    而赋值的含义是把对象的当前值擦除，而以一个新值来替代。%
    一个调用拷贝构造函数，一个调用operator=运算符来完成。}}
\subsection{列表初始化}
想要定义一个名为x的int变量，以下的四种方式都可以完成：\\
int x = 0;\\
int x = \{0\};\\
int x(0);\\
int x\{0\};\\
作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。%
无论是初始化对象还是某些时候为对象赋新值，%
都可以使用这样一组由花括号括起来的初始值了。%
当用于内置类型的变量时，这种初始化有一个重要特点：%
如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。%
\subsection{默认初始化}
如果定义变量时没有指定初值，则变量被默认初始化。%
默认值到底是什么由变量类型决定，%
同时变量定义的位置也会对此有影响。%
对于内置类型，定义在函数之外的变量被初始化为0，%
定义在函数之内的变量未被初始化，%
未被初始化的变量其值是未定义的%

\section{变量声明和定义}
C++语言支持{\bfseries{分离式编译}}。为了支持分离式编译，C++语言将声明和定义区分开来。%
{\color{red}{声明}}使得名字为程序所知，%
一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。%
{\color{red}{定义}}负责创建与名字关联的实体，申请了存储空间。%
如果想声明一个变量而非定义它，就在变量名前添加关键字{\bfseries{extern}}，%
而且不要显示地初始化变量。%
{\color{red}{变量能且只能被定义一次，但是可以被多次声明。}}

\section{命名规范}
变量命名有许多约定俗称的规范，下面的这些规范能有效提高程序的可读性。%
\begin{itemize}
\item{标识符要能体现实际含义。}
\item{变量名一般小写字母。}
\item{用户自定义的类名一般以大写字母开头。}
\item{如果标识符由多个单词组成，则单词间应有明显的区分。{\color{red}{采用驼峰式命名。}}}
\end{itemize}

\section{名字的作用域}
变量的有效区域始于名字的声明语句，%
以声明语句所在的作用域末端为结束。%
作用域运算符为{\bfseries{::}}。
一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，%
因为这样做有助于更容易地找到变量的定义。
\subsection{作用域的嵌套}
作用域可以彼此包含，被包含的作用域称为{\bfseries{内层作用域}}，%
包含着的作用域被称为{\bfseries{外层作用域}}。%
作用域一定那声明了某个名字，它所嵌套着的所有作用域中都可以梵文该名字。%
同时，允许在内层作用域中重新定义外层作用域已有的名字。
\begin{lstlisting}
  #include <iostream>
  int reused = 42;
  int main(int argc, char* argv[])
  {
    int unique = 0;
    std::cout << reused << " " << unique << std::endl;
    int reused = 0;
    std::cout << reused << " " << unique << std::endl;
    std::cout << ::reused << " " << unique << std::endl;
    return 0;
  }
\end{lstlisting}
\alertinfo{当作用域运算符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。}

\section{引用}
{\bfseries{引用}}为对象起了另外一个名字，引用类型引用另外一种类型。%
通过将声明符写成\&x的形式来引用类型。其中x是声明的变量名。
一般在初始化变量时，初始值会被拷贝到新建的对象中。%
然而定义引用时，程序把引用和它的初始值绑定在一起，%
而不是将初始值拷贝给引用。一旦初始化完成，%
引用将和它的初始值对象一直绑定在一起。%
因为无法令引用重新绑定到另外里格对象，{\color{red}因此引用必须初始化}。
\alertinfo{引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。%
  因为引用本身不是一个对象，所以不能定义引用的引用。%
  引用的类型都要和与之绑定的对象严格匹配，而且，引用只能绑定在对象上，%
  而不能与字面值或某个表达式的计算绑定在一起。%
}

\section{指针}
指针是指向另外一种类型的复合对象。%
定义指针类型的方法是将声明符写成*d的形式，其中d是变量名。
\begin{itemize}
\item{指针本身就是一个对象，允许对指针进行赋值和拷贝，%
    而且在指针的生命周期内它可以先后指向几个不同的对象。%
  }
\item{指针无须在定义时进行赋值。}
\end{itemize}
指针存放某个对象的地址，要想获取该地址，需要使用{\bfseries{取地址符\&}}。
\alertinfo{所有指针的类型都要和它所指向的对象严格匹配。(这里有例外)}
\subsection{指针值}
指针值应属于下面四种之一：
\begin{list}{*}{}
\item{指向一个对象。}
\item{指向紧邻对象所占空间的下一个位置。(迭代器哨兵)}
\item{空指针。}
\item{无效指针。}
\end{list}
如果指针指向了一个对象，则允许使用{\bfseries{解引用*}}来访问对象。%
对指针解引用会得出所指的对象。%
\subsection{空指针}
得到空指针最简单的形式就是使用字面值{\bfseries{nullptr}}来初始化指针。%
当然也可以将指针的值初始化为字面值0来生成空指针。
\alerterror{预处理器中的NULL已经是过去式的东西了。}
\subsection{赋值和指针}
指针和引用都能提供对其他对象的间接访问，%
然而在具体的实现细节上二者有很大的区别，%
其中最重要的一点就是引用本身不是一个对象。%
一旦定义了引用，就无法再将它绑定到其它的值上面，%
而指针却可以指向新的值。
\par
有时候要想搞清楚一条语句到底是改变了指针的值还是改变了指针所值对象的值，%
最好的办法就是记住：
\begin{center}
  {\color{red}{赋值永远改变的是等号左边的对象。}}
\end{center}
\subsection{指针作为条件}
只要指针拥有合法的值，就能将其用在条件表达式中。%
如果指针的值是0，条件取false。%
任何非0指针对应的条件值都是true。\\%
指针想等的状态可能对应三种：
\begin{itemize}
\item{都为空。}
\item{指向同一个对象。}
\item{都指向同一个对象的下一个地址。}
\end{itemize}
\subsection{void* 指针}
{\bfseries{void*}}是一种特殊的指针类型，可用于存放任意对象的地址。%
不同的是，我们对该地址中到底是什么类型的对象并不了解。%
\par
利用void*指针能做的事比较有限：拿它和别的指针比较、作为函数的输入和输出，%
或者赋给另外一个void*指针，但是不能直接操作void*指针所指的对象。

\section{复合类型的声明}
定义的变量包括一个基本数据类型和一组声明符。%
在同一条定义语句中，虽然基本数据李诶笑嗯只有一个，%
但是声明符的形式却可以不同。%
\alertwarning{很多人容易迷惑基本数据类型和类型修饰符的关系，%
  其实后者不过是声明符的一部分罢了。
}
\par
经常有一种观点会误以为，在定义语句中，类型修饰符{\bfseries{*或\&}}作用于本次定义的全部变量。%
造成这种错误看法的原因有很多，其中之一就是我们把空格写在类型修饰符和变量名中间：
\begin{lstlisting}
  int* p;
\end{lstlisting}
涉及指针和引用的声明，一般有两种写法。
\begin{itemize}
\item{第一种把修饰符和变量标识符写在一起。\\
    int *p1, *p2;
  }
\item{第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量。\\
    int* p;\\
    int* p2;
  }
\end{itemize}
\alertinfo{推荐采用第一种方式。}
\subsection{指向指针的指针}
指针是内存中的对象，像其他的对象一样也有自己的地址，%
因此允许把指针的地址再存放到另一个指针当中。%
\subsection{指向指针的引用}
引用本身不是一个对象，因此不能定义指向引用的指针。%
但指针是对象，所以存在对指针的引用。
\begin{lstlisting}
  int i = 42;
  int *p;
  int *&r = p;
\end{lstlisting}
\par
{\color{red}要理解r的类型到底是什么，最简单的方式就是从右往左阅读r的定义。%
  离变量名最近的符号(本例中\&r的\&)对变量的类型有直接的影响，%
  因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，%
  此例中的符号*说明r引用的是一个指针。%
  最后，声明的基本数据类型部分指出r引用的是一个int的指针。
}

\section{const限定符}

  



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
