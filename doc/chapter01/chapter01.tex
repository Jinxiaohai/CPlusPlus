\chapter{入门知识}
\section{输入输出}
\noindent{\bfseries{cin}}:处理标准输入。\\
{\bfseries{cout}}:处理标准输出。\\
{\bfseries{cerr}}:输出警告和错误消息。\\
{\bfseries{clog}}:输出程序运行时的一般信息。

\section{标准命名空间}
标准库使用的所有名字都在命名空间{\bfseries{std}}中。%
命名空间可以帮助我们避免不经意的名字定义冲突，%
以及使用库中相同名字导致的冲突。%

\section{流作为条件}
当我们使用一个{\bfseries{istream}}对象作为条件时，其效果是检测流的状态。%
如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符{\bfseries{EOF}},%
或遇到一个无效输入时，%
{\bfseries{istream}}对象的状态会变为无效。%
处于无效状态的{\bfseries{istream}}对象会使条件为假。

\section{基本内置类型}
C++定义了一套包括{\bfseries{算术类型}}和{\bfseries{空类型}}在内的基本数据类型。%
其中算术类型包含了字符、整型数、布尔值和浮点型。%
空类型不对应具体的值，%
仅用于一些特殊的场合。%

\section{带符号类型和无符号类型}
除去布尔值类型和扩展的字符类型之外，其他的整型可以分为{\bfseries{带符号的}}和{\bfseries{无符号的}}两种。%
带符号的类型可以表示{\bfseries{正数}}、{\bfseries{负数}}和{\bfseries{0}}。%

\section{类型转换}
\begin{itemize}
\item{当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0，则结果为false，否则结果为true。}
\item{当我们把一个布尔类型的值赋给非布尔类型时，初始值为false，则结果为0，否则结果为1。}
\item{当我们把一个浮点值赋给整数时，采取的是截断处理，将仅保留小数点之前的值。}
\item{当我们把一个整数赋给浮点数时，小数部分为0。此时要注意两者的所占空间的大小。}
\item{当我们赋给带符号类型一个超出它表示范围的值时，结果是{\bfseries{为定义的}}。}
\end{itemize}

\section{进制}
以0开头的整数代表八进制，以0x和0X开头的代表十六进制数。

\section{转义序列}
\begin{table}[hbpt]
  \centering
  \begin{tabular}{cc}\hline\hline
    换行符 & $\backslash{n}$ \\\hline
    纵向制表符 & $\backslash{v}$ \\\hline
    反斜线 & $\backslash{\backslash}$ \\\hline
    回车符 & $\backslash{r}$ \\\hline
    横向制表符 & $\backslash{t}$ \\\hline
    退格符 & $\backslash{b}$ \\\hline
    问号 & $\backslash{?}$ \\\hline
    进纸符 & $\backslash{f}$ \\\hline
    报警符 & $\backslash{a}$ \\\hline
    双引号 & $\backslash{"}$ \\\hline
    单引号 & $\backslash{'}$ \\\hline\hline
  \end{tabular}
  \caption{C++转义序列}
\end{table}

\section{变量}
变量提供了一个具名的、可供程序操作的存储空间。
\subsection{变量定义}
变量定义的基本形式是：首先是类型说明符，
随后紧跟由一个或多个变量名组成的列表，%
其中变量名以逗号分隔，%
最后以分号结束。%
列表中每个变量名的类型都由类型说明符指定，%
定义时还可以为一个或多个变量赋初值。%
\subsection{初始值}
当对象在创建时获得了一个特定的值，我们说这个对象被{\bfseries{初始化}}了。\\%
{\color{red}{初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，%
    而赋值的含义是把对象的当前值擦除，而以一个新值来替代。%
    一个调用拷贝构造函数，一个调用operator=运算符来完成。}}
\subsection{列表初始化}
想要定义一个名为x的int变量，以下的四种方式都可以完成：\\
int x = 0;\\
int x = \{0\};\\
int x(0);\\
int x\{0\};\\
作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。%
无论是初始化对象还是某些时候为对象赋新值，%
都可以使用这样一组由花括号括起来的初始值了。%
当用于内置类型的变量时，这种初始化有一个重要特点：%
如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。%
\subsection{默认初始化}
如果定义变量时没有指定初值，则变量被默认初始化。%
默认值到底是什么由变量类型决定，%
同时变量定义的位置也会对此有影响。%
对于内置类型，定义在函数之外的变量被初始化为0，%
定义在函数之内的变量未被初始化，%
未被初始化的变量其值是未定义的%

\section{变量声明和定义}
C++语言支持{\bfseries{分离式编译}}。为了支持分离式编译，C++语言将声明和定义区分开来。%
{\color{red}{声明}}使得名字为程序所知，%
一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。%
{\color{red}{定义}}负责创建与名字关联的实体，申请了存储空间。%
如果想声明一个变量而非定义它，就在变量名前添加关键字{\bfseries{extern}}，%
而且不要显示地初始化变量。%
{\color{red}{变量能且只能被定义一次，但是可以被多次声明。}}

\section{命名规范}
变量命名有许多约定俗称的规范，下面的这些规范能有效提高程序的可读性。%
\begin{itemize}
\item{标识符要能体现实际含义。}
\item{变量名一般小写字母。}
\item{用户自定义的类名一般以大写字母开头。}
\item{如果标识符由多个单词组成，则单词间应有明显的区分。{\color{red}{采用驼峰式命名。}}}
\end{itemize}

\section{名字的作用域}
变量的有效区域始于名字的声明语句，%
以声明语句所在的作用域末端为结束。%
作用域运算符为{\bfseries{::}}。
一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，%
因为这样做有助于更容易地找到变量的定义。
\subsection{作用域的嵌套}
作用域可以彼此包含，被包含的作用域称为{\bfseries{内层作用域}}，%
包含着的作用域被称为{\bfseries{外层作用域}}。%
作用域一定那声明了某个名字，它所嵌套着的所有作用域中都可以梵文该名字。%
同时，允许在内层作用域中重新定义外层作用域已有的名字。
\begin{lstlisting}
  #include <iostream>
  int reused = 42;
  int main(int argc, char* argv[])
  {
    int unique = 0;
    std::cout << reused << " " << unique << std::endl;
    int reused = 0;
    std::cout << reused << " " << unique << std::endl;
    std::cout << ::reused << " " << unique << std::endl;
    return 0;
  }
\end{lstlisting}
\alertinfo{当作用域运算符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。}

\section{引用}
{\bfseries{引用}}为对象起了另外一个名字，引用类型引用另外一种类型。%
通过将声明符写成\&x的形式来引用类型。其中x是声明的变量名。
一般在初始化变量时，初始值会被拷贝到新建的对象中。%
然而定义引用时，程序把引用和它的初始值绑定在一起，%
而不是将初始值拷贝给引用。一旦初始化完成，%
引用将和它的初始值对象一直绑定在一起。%
因为无法令引用重新绑定到另外里格对象，{\color{red}因此引用必须初始化}。
\alertinfo{引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。%
  因为引用本身不是一个对象，所以不能定义引用的引用。%
  引用的类型都要和与之绑定的对象严格匹配，而且，引用只能绑定在对象上，%
  而不能与字面值或某个表达式的计算绑定在一起。%
}

\section{指针}
指针是指向另外一种类型的复合对象。%
定义指针类型的方法是将声明符写成*d的形式，其中d是变量名。
\begin{itemize}
\item{指针本身就是一个对象，允许对指针进行赋值和拷贝，%
    而且在指针的生命周期内它可以先后指向几个不同的对象。%
  }
\item{指针无须在定义时进行赋值。}
\end{itemize}
指针存放某个对象的地址，要想获取该地址，需要使用{\bfseries{取地址符\&}}。
\alertinfo{所有指针的类型都要和它所指向的对象严格匹配。(这里有例外)}
\subsection{指针值}
指针值应属于下面四种之一：
\begin{list}{*}{}
\item{指向一个对象。}
\item{指向紧邻对象所占空间的下一个位置。(迭代器哨兵)}
\item{空指针。}
\item{无效指针。}
\end{list}
如果指针指向了一个对象，则允许使用{\bfseries{解引用*}}来访问对象。%
对指针解引用会得出所指的对象。%
\subsection{空指针}
得到空指针最简单的形式就是使用字面值{\bfseries{nullptr}}来初始化指针。%
当然也可以将指针的值初始化为字面值0来生成空指针。
\alerterror{预处理器中的NULL已经是过去式的东西了。}
\subsection{赋值和指针}
指针和引用都能提供对其他对象的间接访问，%
然而在具体的实现细节上二者有很大的区别，%
其中最重要的一点就是引用本身不是一个对象。%
一旦定义了引用，就无法再将它绑定到其它的值上面，%
而指针却可以指向新的值。
\par
有时候要想搞清楚一条语句到底是改变了指针的值还是改变了指针所值对象的值，%
最好的办法就是记住：
\begin{center}
  {\color{red}{赋值永远改变的是等号左边的对象。}}
\end{center}
\subsection{指针作为条件}
只要指针拥有合法的值，就能将其用在条件表达式中。%
如果指针的值是0，条件取false。%
任何非0指针对应的条件值都是true。\\%
指针想等的状态可能对应三种：
\begin{itemize}
\item{都为空。}
\item{指向同一个对象。}
\item{都指向同一个对象的下一个地址。}
\end{itemize}
\subsection{void* 指针}
{\bfseries{void*}}是一种特殊的指针类型，可用于存放任意对象的地址。%
不同的是，我们对该地址中到底是什么类型的对象并不了解。%
\par
利用void*指针能做的事比较有限：拿它和别的指针比较、作为函数的输入和输出，%
或者赋给另外一个void*指针，但是不能直接操作void*指针所指的对象。

\section{复合类型的声明}
定义的变量包括一个基本数据类型和一组声明符。%
在同一条定义语句中，虽然基本数据李诶笑嗯只有一个，%
但是声明符的形式却可以不同。%
\alertwarning{很多人容易迷惑基本数据类型和类型修饰符的关系，%
  其实后者不过是声明符的一部分罢了。
}
\par
经常有一种观点会误以为，在定义语句中，类型修饰符{\bfseries{*或\&}}作用于本次定义的全部变量。%
造成这种错误看法的原因有很多，其中之一就是我们把空格写在类型修饰符和变量名中间：
\begin{lstlisting}
  int* p;
\end{lstlisting}
涉及指针和引用的声明，一般有两种写法。
\begin{itemize}
\item{第一种把修饰符和变量标识符写在一起。\\
    int *p1, *p2;
  }
\item{第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量。\\
    int* p;\\
    int* p2;
  }
\end{itemize}
\alertinfo{推荐采用第一种方式。}
\subsection{指向指针的指针}
指针是内存中的对象，像其他的对象一样也有自己的地址，%
因此允许把指针的地址再存放到另一个指针当中。%
\subsection{指向指针的引用}
引用本身不是一个对象，因此不能定义指向引用的指针。%
但指针是对象，所以存在对指针的引用。
\begin{lstlisting}
  int i = 42;
  int *p;
  int *&r = p;
\end{lstlisting}
\par
{\color{red}要理解r的类型到底是什么，最简单的方式就是从右往左阅读r的定义。%
  离变量名最近的符号(本例中\&r的\&)对变量的类型有直接的影响，%
  因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，%
  此例中的符号*说明r引用的是一个指针。%
  最后，声明的基本数据类型部分指出r引用的是一个int的指针。
}

\section{const限定符}
有时我们希望定义这样一种变量，它的值不能被改变。%
为了满足这一要求，可以用关键字{\bfseries{const}}对变量的类型加以限定。%
\begin{lstlisting}
  const int bufSize = 1024;
\end{lstlisting}
因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。%
\subsection{初始化和const}
const对象和非const对象的主要区别就是，只能在const类型的对象上执行不改变内容的操作。%
在不改变const对象的操作中还有一种是初始化，%
如果利用一个对象去初始化另外一个对象，%
则它们是不是const都无关紧要。如%
\begin{lstlisting}
  int i = 123;
  const int ci = i;
\end{lstlisting}

\subsection{const对象仅在文件内有效}
编译器将在编译过程中把用到常量变量的地方都替换成相应的值。%
为了执行替换，编译器必须知道变量的初始值。%
如果程序包含多个文件，则每个用了const对象的文件都必须得到访问它的初始值才行。%
要做到这一点就必须在每一个用到变量的文件中都有它的定义。%
为了支持这一用法，同时避免对同一变量的重复定义。%
const被限定为仅在文件内有效。
\subsection{const引用}
可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用。%
与普通引用不同，对常量的引用不能被用作修改它所绑定的对象。
\subsection{初始化和const的引用}
引用的类型必须与其所引用对象的类型一致。但是有两个例外：%
\begin{itemize}
\item{在初始化常量引用时允许用任意表达式作为初始值，%
    只要该表达式的结果可以转换成引用的类型即可。
  }
\item{编译器生辰过的临时量。}
\end{itemize}
\subsection{指针和const}
和引用一样，也可以令指针指向常量或者非常量。类似于常量引用，%
指向常量的指针不能用于改变其所指的对象的值。%
\alertinfo{所谓指向常量的指针或引用，不过是指针或引用\textquotedblleft{自以为是}\textquotedblright{}罢了，%
  它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。
}
\par
指针是对象而引用不是，因此就像其他对象类型一样，%
允许把指针本生定义为常量。%
常量指针必须初始化，而且一但初始化完成，则它的值就不能再改变了。%
把*放在const关键字之前用以说明指针是一个常量。%
这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值。%
\begin{lstlisting}
  int errNumb = 0;
  int *const cerErr = &errNumb;
  const double PI = 3.1415926;
  const double *const pip = &pi;
\end{lstlisting}
要想弄清楚这些声明的含义，最行之有效的方法就是从右往左阅读。%
此例中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，%
对象的类型由声明符的其余部分确定。%
声明符中的下一个符号是*，意味着curerr是一个常量指针。%
最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。%
\par
指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，%
能否这样做完全依赖于所指向的对象的类型。%
\subsection{顶层和底层const}
指针本身是不是常量以及指针所指的是不是一个常量是两个相互独立的问题。%
用名词{\bfseries{顶层const}}表示指针本身是个常量。%
用名字{\bfseries{底层const}}表示指针所指的值是个常量。
\par
更一般的，顶层const可以表示任意的对象是常量，%
这一点对任何数据类型都适用，如算术类型、类、指针等。%
底层const则与指针和引用等复合类型的基本类型部分有关。%
比较特殊的是，指针类型既可以是顶层const也可以是底层const，%
这一点和其它类型相比区别明显。
\begin{lstlisting}
  int i = 0; 
  int *const p1 = &i; // 不能改变p1的值，这是一个顶层const.
  const int ci = 42; // 不能改变ci的值，这是一个顶层const.
  const int *p2 = &ci; // 允许改变p2的值，这是一个底层const.
  const int *const p3 = p2; // 靠右的const是顶层const，靠左的const是底层const.
  const int &r = ci; // 用于声明引用的const都是底层const.
\end{lstlisting}
\subsection{常量表达式和constexpr}
常量表达式是指{\bfseries{值不会改变并且在编译过程就能得到计算结果的表达式}}。%
显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。%
\subsection{constexpr变量}
在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。%
C++11规定，允许将变量声明为{\bfseries{constexpr}}类型以便由编译器来验证变量的时是否是一个常量表达式。%
声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：
\begin{lstlisting}
  constexpr int mf = 20; // 20是常量表达式
  constexpr int limit = mf + 1; // mf + 1 是常量表达式
  constexpr int sz = size(); // 只有当size是一个constexpr函数时才是一条正确的声明语句
\end{lstlisting}
\alertinfo{一把来说，如果你认为变量是一个常量表达式，那就把它声明为constexpr类型。}

\section{类型处理}
随着程序越来越复杂，程序中用到的类型也越来越复杂。%
这主要表现在：
\begin{itemize}
\item{一些类型难于拼写。}
\item{根本搞不清楚到底需要的类型是什么。}
\end{itemize}
有两种方法可用于定义类型别名。传统的方法是使用关键字{\bfseries{typedef}}。%
\begin{lstlisting}
  typedef double wages;
\end{lstlisting}
含有typedef的声明语句定义的不再是变量而是类型别名。\\
新标准规定了一种新的方法，使用{\bfseries{别名声明}}来定义类型的别名。
\begin{lstlisting}
  using wages = double;
\end{lstlisting}
这种方法用关键字using作为别名声明的开始，%
其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。%
\subsection{auto类型说明符}
编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。%
然而要做到这一点并非那么容易，有时甚至做不到。%
为了解决这个问题，C++新标准引入了{\bfseries{auto}}类型说明符，%
用它就能让编译器替我们分析表达式所属的类型。%
显然，auto定义的变量必须有初始值：
\begin{lstlisting}
  auto item = val1 + val2; // item初始化为val1和val2相加的结果
\end{lstlisting}
\subsection{复合类型、常来和auto}
编译器推断出来的auto类型有时候和初始值的类型并不完全一样，%
编译器会适当地改变结果类型使其更符合初始化规则。%
\par
首先，正如我们所熟知的，使用引用其实是使用引用的对象，%
特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。%
此时编译器以引用对象的类型作为auto的类型。
\par
其次，auto一般会忽略掉顶层const，同时保留底层const。%
如果我们希望推断出的auto类型是一个顶层const，需要明确指出：
\begin{lstlisting}
  const auto f = ci; // ci的推演如果是int，f则是const int.
\end{lstlisting}
\subsection{decltype类型指示符}
有时我们遇到这种情况：希望从表达式的类型推断出要定义的变量的类型。%
但是不想用该表达式的值初始化变量。%
为了满足这一要求，C++11引入了第二种类型说明符{\bfseries{decltype}}，%
它的作用是选择并返回操作数的数据类型。%
在此过程中，编译器分析表达式并得到它的数据类型，%
却不实际计算表达式的值：
\begin{lstlisting}
  decltype(function()) sum = x; // sum的类型就是函数function的返回类型。
\end{lstlisting}
\par
decltype处理顶层const和引用的方式与auto有写不同。%
如果decltype使用的表达式是一个变量，%
则decltype返回该变量的类型(包括顶层const和引用在内)：
\begin{lstlisting}
  const int ci = 0, &cj = ci;
  decltype(ci) x = 0; // x的类型是const int
  decltype(cj) y = x; // y的类型是const int&, y绑定到变量x
  decltype(cj) z; // 错误
\end{lstlisting}

\section{头文件}
为了确保各个文件中类的定义一致，类通常定义在头文件中，%
而且类所在的头文件的名字应与类名一致，%
头文件通常包含那些只被定义一次的实体。%
\alertwarning{头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。}
C++程序还会用到的一项预处理功能是{\bfseries{头文件保护符}}，%
头文件保护符依赖于预处理变量。预处理变量有两种状态：%
已定义和未定义。%
{\bfseries{\#define}}指令把一个名字设定为预处理变量，%
另外两个指令则分别检查某个指定的预处理变量是否已经定义：%
{\bfseries{\#ifdef}}当且仅当变量已定义时为真，%
{\bfseries{\#ifndef}}当且仅当变量未定义时为真。%
一旦检测结果为真，则会执行后续操作直到遇到{\bfseries{\#endif}}指令为止。%
一般把预处理变量的名字全部大写。





%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
