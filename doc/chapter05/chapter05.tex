\chapter{难啃的骨头}
\section{成员运算符的重载}
在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符($->$)。%
我们以如下形式向StrBlobPtr类添加这两种运算符：
\begin{lstlisting}
  class StrBlobPtr
  {
    public:
    std::string& operator*() const
    {
      auto p = check(curr, "dereference past end");
      return (*p)[curr];
    }
    std::string* operator->() const
    {
      return & this->operator*();
    }
  };
\end{lstlisting}
解引用运算符返回所指元素的一个引用。%
箭头运算符不执行任何自己的操作，%
而是调用解引用运算符并返回解引用结果元素的地址。%
\alertinfo{箭头运算符必须是类的成员。%
  解引用运算符通常也是类的成员，%
  尽管并非必须如此。
}
值得注意的是，我们将这两个运算符定义成了const成员，%
这是因为获取一个元素并不会改变StrBlobPtr对象的状态。%
同时，它们的返回值分别是非常量string的引用和指针，%
因为StrBlobPtr只能绑定到非常量的StrBlobPtr对象。%
\subsection{对箭头运算符返回值的限定}
和大多数其它运算符一样，我们能令operator*完成任何我们指定的操作。%
换句话说，我们可以让operator*返回一个固定值42，%
或者打印对象的内容，或者其它。%
箭头运算符则不是这样，%
它永远不能丢掉成员访问这个最基本的含义。%
当我们重载箭头时，%
可以改变的是箭头从哪个对象当中获取成员，%
而箭头获取成员这一事实则永远不同。%
\par
对于形如$point->$mem的表达式来说，%
point必须是指向类对象的指针或者是一个重载了operator$->$的类的对象。%
根据point类型的不同，%
$point->mem$分别等价于
\begin{lstlisting}
  (*point).mem; // point是一个内置的指针类型
  point.operator()->mem； // point是类的一个对象
\end{lstlisting}
除此之外，代码将发生错误。%
point->mem的执行过程如下所是：
\begin{itemize}
\item{如果point是指针，则我们应用内置的箭头运算符，%
    表达式等价于(*point).mem。首先解引用该指针，%
    然后从所得的对象中获取指定的成员。%
    如果point所指的类型没有名为mem的成员，%
    程序会发生错误。
  }
\item{如果point是定义了operator的类的一个对象，%
    则我们使用$point.operator->()$的结果来获取mem。%
    其中，如果该结果是一个指针，则执行第一步。%
    如果该结果本身含有重载的$operator->()$，%
    则重复调用当前步骤。%
    最终，当这一过程结束时程序或者返回了所需要的内容，%
    或者返回了一些表示程序错误的信息。
  }
\end{itemize}
\alertinfo{重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对像。}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
